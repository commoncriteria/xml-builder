// Imports
import PropTypes from "prop-types";
import { v4 as uuidv4 } from "uuid";
import { useEffect, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { Card, CardBody } from "@material-tailwind/react";
import { FormControl, IconButton, InputLabel, MenuItem, Select, TextField, Tooltip } from "@mui/material";
import AddIcon from "@mui/icons-material/Add";
import AddCircleIcon from "@mui/icons-material/AddCircle";
import RemoveIcon from "@mui/icons-material/Remove";
import { UPDATE_SFR_SECTION_ELEMENT_SELECTABLE } from "../../../../../../reducers/SFRs/sfrSectionSlice.js";
import { deepCopy } from "../../../../../../utils/deepCopy.js";
import { removeTagEqualities } from "../../../../../../utils/fileParser.js";
import { handleSnackBarError, handleSnackBarSuccess, handleSnackbarTextUpdates, updateSfrSectionElement } from "../../../../../../utils/securityComponents.jsx";
import CardTemplate from "../../../CardTemplate.jsx";
import EditableTable from "../../../../EditableTable.jsx";
import SfrComplexSelectableCard from "./SfrComplexSelectableCard.jsx";
import SfrSelectionGroupCard from "./SfrSelectionGroupCard.jsx";

/**
 * The SfrSelectionGroups class that displays the selection groups per f-element
 * @returns {JSX.Element} the content
 * @constructor passes in props to the class
 */
function SfrSelectionGroups(props) {
  // Prop Validation
  SfrSelectionGroups.propTypes = {
    styling: PropTypes.object.isRequired,
    requirementType: PropTypes.string.isRequired,
  };

  // Constants
  const dispatch = useDispatch();
  const { icons, lightGray } = useSelector((state) => state.styling);
  const { sfrSections } = useSelector((state) => state);
  const { sfrUUID, componentUUID, elementUUID, element } = useSelector((state) => state.sfrWorksheetUI);
  const [collapse, setCollapse] = useState(true);
  const [selectableType, setSelectableType] = useState("Selectable");
  const [selectableID, setSelectableID] = useState("");
  const [assignmentDescription, setAssignmentDescription] = useState("");
  const [selectableDescription, setSelectableDescription] = useState("");
  const [selectableDisabled, setSelectableDisabled] = useState(true);
  const [selectableGroupType, setSelectableGroupType] = useState("Selectable Group");
  const [selectableGroupID, setSelectableGroupID] = useState("");
  const [complexSelectableID, setComplexSelectableID] = useState("");
  const [selectableGroupDisabled, setSelectableGroupDisabled] = useState(true);
  const [rowData, setRowData] = useState([]);
  const [collapseInnerTableSection, setCollapseInnerTableSection] = useState(false);
  const editable = { addColumn: false, addRow: false, removeColumn: false, removeRow: true };
  const columnData = [
    {
      headerName: "ID",
      field: "id",
      editable: true,
      resizable: true,
      type: "Editor",
      flex: 1.5,
      headerTooltip: "The ID of the selectable or assignment. Selectables or assignments without IDs have one autogenerated upon export.",
    },
    {
      headerName: "Text",
      field: "text",
      editable: false,
      resizable: true,
      type: "Editor",
      flex: 2.5,
      headerTooltip: "The value of the selectable or assignment.",
    },
    {
      headerName: "Not Selectable",
      field: "notSelectable",
      editable: true,
      resizable: true,
      type: "Checkbox",
      flex: 0.75,
      headerTooltip: "Selections that must be viewable, but not selectable.",
    },
    {
      headerName: "Exclusive",
      field: "exclusive",
      editable: true,
      resizable: true,
      type: "Checkbox",
      flex: 0.75,
      headerTooltip: "Selections that when selected, exclude all other selections.",
    },
  ];
  const { styling } = props;

  // Use Effects
  useEffect(() => {
    try {
      generateRowData();
    } catch (e) {
      console.log(e);
      handleSnackBarError(e);
    }
  }, [sfrSections, props]);

  // Methods
  /**
   * Handles the selectable id
   * @param event the event
   */
  const handleSelectableID = (event) => {
    let trimmed = event.target.value.trim();
    setSelectableID(trimmed);
  };
  /**
   * Handles the assignment description
   * @param event the event
   */
  const handleAssignmentDescription = (event) => {
    let description = event.target.value;
    setAssignmentDescription(description);
    setSelectableDisabled(description !== "" ? false : true);
  };
  /**
   * Handles the selectable description
   * @param event the event
   */
  const handleSelectableDescription = (event) => {
    let description = event.target.value;
    setSelectableDescription(description);
    setSelectableDisabled(description !== "" ? false : true);
  };
  /**
   * Handles deleting the selectable
   * @param newData the new data
   * @param selectedData the selected data
   */
  const handleDeleteSelectable = (newData, selectedData) => {
    let selectables = element.selectables ? deepCopy(element.selectables) : {};
    let selectableGroups = element.selectableGroups ? deepCopy(element.selectableGroups) : {};
    let title = element.title ? deepCopy(element.title) : [];
    let managementFunctions = element.managementFunctions ? deepCopy(element.managementFunctions) : {};

    // Delete associated values accordingly
    selectedData.forEach((row) => {
      const { uuid } = row;

      // Delete selectable from selectables that contain the uuid key
      delete selectables[uuid];

      // Delete selection groups index that contain the selection uuid key
      Object.values(selectableGroups).map((group) => {
        let groups = group.groups;
        if (groups && groups.includes(uuid)) {
          let index = groups.findIndex((value) => uuid === value);
          if (index !== -1) {
            groups.splice(index, 1);
          }
        }
      });

      // Delete title assignment sections that contain the selection uuid key
      title.map((section, index) => {
        if (section.hasOwnProperty("assignment") && section.assignment === uuid) {
          title.splice(index, 1);
        }
      });

      // Delete management function sections that contain the selection uuid key
      if (
        element.hasOwnProperty("isManagementFunction") &&
        element.isManagementFunction &&
        element.hasOwnProperty("managementFunctions") &&
        element.managementFunctions.hasOwnProperty("rows")
      ) {
        managementFunctions.rows.map((row) => {
          let { textArray } = row;
          textArray.map((section, index) => {
            if (section.hasOwnProperty("assignment") && section.assignment === uuid) {
              textArray.splice(index, 1);
            }
          });
        });
      }
    });

    // Update the objects
    let itemMap = {
      selectables: selectables,
      selectableGroups: selectableGroups,
      title: title,
    };

    // Update management functions if they were updated
    if (element.managementFunctions && JSON.stringify(managementFunctions) !== JSON.stringify(element.managementFunctions)) {
      itemMap.managementFunctions = managementFunctions;
    }

    // Update the sfr section element
    updateSfrSectionElement(itemMap);
  };
  /**
   * Handles the selectable checkbox selection
   * @param event the event
   * @param type the type
   * @param uuid the uuid
   */
  const handleSelectableCheckboxSelection = (event, type, uuid) => {
    // Update selectable checkbox for exclusive or not selectable types
    if (type === "exclusive" || type === "notSelectable") {
      let itemMap = {
        [type]: event.target.checked,
      };
      updateSelectable(uuid, itemMap);
    }
  };
  /**
   * Handles the new selectable submit
   * @returns {Promise<void>}
   */
  const handleNewSelectableSubmit = async () => {
    if (selectableType === "Assignment" || selectableType === "Selectable") {
      let selectables = element.selectables ? deepCopy(element.selectables) : {};
      let idExists = false;
      let descriptionExists = false;
      Object.values(selectables).map((value) => {
        let id = value.id;
        let description = value.description;
        if (selectableID !== "" && selectableID === id) {
          idExists = true;
        }
        if (selectableType === "Selectable" && selectableDescription !== "" && selectableDescription === description) {
          descriptionExists = true;
        }
        if (selectableType === "Assignment" && assignmentDescription !== "" && assignmentDescription === description) {
          descriptionExists = true;
        }
      });
      if (!idExists && !descriptionExists) {
        let uuid = uuidv4();
        if (selectableType === "Selectable") {
          selectables[uuid] = {
            id: selectableID,
            description: selectableDescription,
            assignment: false,
          };
        } else if (selectableType === "Assignment") {
          selectables[uuid] = {
            id: selectableID,
            description: assignmentDescription,
            assignment: true,
          };
        }

        // Update sfr section element
        updateSfrSectionElement({
          selectables,
        });

        // Reset Item Values
        setSelectableID("");
        setAssignmentDescription("");
        setSelectableDescription("");
        setSelectableType("Selectable");
        setSelectableDisabled(true);

        // Update snackbar
        handleSnackBarSuccess(`${selectableType} Successfully Added`);
      } else {
        if (idExists) {
          setSelectableID("");
        }
        if (descriptionExists) {
          setSelectableDescription("");
          setAssignmentDescription("");
        }
      }
    }
  };
  /**
   * Handles setting the selectable group type
   * @param event the event
   */
  const handleSetSelectableGroupType = (event) => {
    setSelectableGroupType(event.target.value);
  };
  /**
   * Handles the complex selectable ID
   * @param event the event
   */
  const handleComplexSelectableID = (event) => {
    let trimmed = event.target.value.trim();
    setComplexSelectableID(trimmed);
    setSelectableGroupDisabled(selectableGroupType === "Complex Selectable" && trimmed !== "" ? false : true);
  };
  /**
   * Handles the selectable group id
   * @param event the event
   */
  const handleSelectableGroupID = (event) => {
    let trimmed = event.target.value.trim();
    setSelectableGroupID(trimmed);
    setSelectableGroupDisabled(selectableGroupType === "Selectable Group" && trimmed !== "" ? false : true);
  };
  /**
   * Handles the new selectable group submit
   */
  const handleNewSelectableGroupSubmit = () => {
    let selectableGroups = element.selectableGroups ? deepCopy(element.selectableGroups) : {};
    let idExists = false;

    if (selectableGroupType && selectableGroupType === "Selectable Group") {
      if (selectableGroups.hasOwnProperty(selectableGroupID)) {
        idExists = true;
      }
      if (!idExists) {
        selectableGroups[selectableGroupID] = {
          onlyOne: false,
          groups: [],
        };

        // Update sfr section element
        updateSfrSectionElement({
          selectableGroups,
        });
        setSelectableGroupDisabled(true);

        // Update snackbar
        handleSnackBarSuccess(`${selectableGroupType} Successfully Added`);
      }
    } else if (selectableGroupType && selectableGroupType === "Complex Selectable") {
      if (selectableGroups.hasOwnProperty(complexSelectableID)) {
        idExists = true;
      }
      if (!idExists) {
        selectableGroups[complexSelectableID] = {
          exclusive: false,
          notSelectable: false,
          description: [],
        };

        // Update sfr section element
        updateSfrSectionElement({
          selectableGroups,
        });
        setSelectableGroupDisabled(true);
      }
    }
    setSelectableGroupID("");
    setComplexSelectableID("");

    // Update snackbar
    if (selectableGroupType && (selectableGroupType === "Selectable Group" || selectableGroupType === "Complex Selectable")) {
      if (!idExists) {
        handleSnackBarSuccess(`${selectableGroupType} Successfully Added`);
      } else {
        handleSnackBarError(`${selectableGroupType} Already Exists`);
      }
    }
  };
  /**
   * Handles the set selectable type
   * @param event the event
   */
  const handleSetSelectableType = (event) => {
    setSelectableType(event.target.value);
  };
  /**
   * Handles the id text update
   * @param event the event
   */
  const handleIdTextUpdate = (event) => {
    const { data, value } = event;
    const { uuid } = data;
    let selectables = element.selectables ? deepCopy(element.selectables) : {};

    if (selectables.hasOwnProperty(uuid)) {
      selectables[uuid].id = value;

      // Update selectables for the selected element
      updateSfrSectionElement({
        selectables,
      });
    }
  };
  /**
   * Handles the collapse inner table section
   */
  const handleCollapseInnerTableSection = () => {
    setCollapseInnerTableSection(!collapseInnerTableSection);
  };

  // Helper Methods
  /**
   * Generates the row data
   */
  const generateRowData = () => {
    try {
      if (element && element.hasOwnProperty("selectables") && Object.entries(element.selectables).length > 0) {
        let updatedRows = [];
        Object.entries(element.selectables).forEach(([key, value]) => {
          const { id, notSelectable, exclusive } = value;
          let row = {
            uuid: key,
            id: id ? id : "",
            text: getTableText(value),
            notSelectable: notSelectable || false,
            exclusive: exclusive || false,
          };
          updatedRows.push(row);
        });
        if (JSON.stringify(updatedRows) !== JSON.stringify(rowData)) {
          setRowData(updatedRows);
        }
      } else {
        setRowData([]);
      }
    } catch (e) {
      console.log(e);
      handleSnackBarError(e);
    }
  };
  /**
   * Gets the table text
   * @param value the value
   * @returns {string|React.JSX.Element|React.JSX.Element[]|*|string}
   */
  const getTableText = (value) => {
    const escapedContent = removeTagEqualities(value.description, false);

    try {
      if (value.assignment && value.assignment === true) {
        return `<strong>assignment</strong>: ${escapedContent}`;
      } else {
        return escapedContent;
      }
    } catch (e) {
      console.log(e);
      handleSnackBarError(e);
    }
  };
  /**
   * Update the selectable
   * @param selectableUUID the selectable UUID
   * @param itemMap the item map
   */
  const updateSelectable = (selectableUUID, itemMap) => {
    dispatch(
      UPDATE_SFR_SECTION_ELEMENT_SELECTABLE({
        sfrUUID: sfrUUID,
        componentUUID: componentUUID,
        elementUUID: elementUUID,
        selectableUUID: selectableUUID,
        itemMap: itemMap,
      })
    );
  };

  // Components
  /**
   * The selectable card section
   * @returns {*[]|null}
   */
  const getSelectableCard = () => {
    return element && element.selectableGroups && Object.keys(element.selectableGroups).length > 0
      ? Object.entries(element.selectableGroups).map(([key, value]) => {
          return (
            <div key={`${key}-selectables-card`} className='mb-2 mx-[-16px]'>
              {value.hasOwnProperty("groups") ? (
                <SfrSelectionGroupCard id={key} styling={props.styling} />
              ) : (
                <div>{value.hasOwnProperty("description") && <SfrComplexSelectableCard id={key} styling={props.styling} />}</div>
              )}
            </div>
          );
        })
      : null;
  };

  // Return Method
  return (
    <div className='p-2 px-4'>
      <Card className='w-full rounded-lg border-2 border-gray-200'>
        <CardBody className='w-full m-0 p-0 border-b-2 border-gray-200'>
          <div className='w-full border-b-2 border-b-gray-200 p-4 pb-2'>
            <span className='min-w-full inline-flex items-baseline'>
              <div className='w-[1%]'>
                <IconButton
                  sx={{ marginTop: "-12px" }}
                  onClick={() => {
                    setCollapse(!collapse);
                    if (!collapse) {
                      setCollapseInnerTableSection(false);
                    }
                  }}
                  key={"SelectionGroupsToolTip"}
                  variant='contained'>
                  <Tooltip
                    title={`${(!collapse ? "Collapse " : "Expand ") + "Selection Groups"}`}
                    id={(collapse ? "collapse" : "expand") + "SelectionGroupsTooltip"}>
                    {!collapse ? (
                      <RemoveIcon htmlColor={styling.primaryColor} sx={icons.large} />
                    ) : (
                      <AddIcon htmlColor={styling.primaryColor} sx={icons.large} />
                    )}
                  </Tooltip>
                </IconButton>
              </div>
              <div className='w-[95%] justify-items-center'>
                <label style={{ color: styling.primaryColor }} className={`resize-none font-bold text-[14px] p-0 mt-1`}>
                  Selection Group
                </label>
              </div>
            </span>
          </div>
          {!collapse && (
            <div className='py-2 w-full'>
              <div className='m-0 p-0 px-4 mt-2 w-full max-w-6xl mb-[-8px]'>
                <div className='relative'>
                  <EditableTable
                    title={
                      <Tooltip id={"groupsItemListTooltip"} arrow>
                        <label style={{ color: styling.secondaryColor }}>Item List</label>
                      </Tooltip>
                    }
                    editable={editable}
                    columnData={columnData}
                    rowData={rowData}
                    handleCheckboxClick={handleSelectableCheckboxSelection}
                    handleUpdateTableRow={handleIdTextUpdate}
                    handleDeleteTableRows={handleDeleteSelectable}
                    handleCollapseInnerTableSection={handleCollapseInnerTableSection}
                    bottomBorderCss={collapseInnerTableSection ? "rounded-b-[0px] shadow-none" : ""}
                    styling={props.styling}
                    requirementType={props.requirementType}
                    tableInstructions={`This section houses all pre-defined selections and assignments 
                                                            to be used in the Selectables section below.`}
                  />
                </div>
                {collapseInnerTableSection && (
                  <div className='relative border-2 border-t-0 rounded-b-md border-[#d0d5db] m-0 pt-6 pb-2' style={{ top: "-20px" }}>
                    <div className='p-2 px-4'>
                      <span className='min-w-full inline-flex items-baseline'>
                        <div className='w-[17%]'>
                          <FormControl fullWidth color={styling.secondaryTextField}>
                            <InputLabel key='element-select-label'>Selectable Type</InputLabel>
                            <Select value={selectableType} label='Selectable Type' autoWidth onChange={handleSetSelectableType} sx={{ textAlign: "left" }}>
                              <MenuItem sx={styling.primaryMenu} key={"Assignment"} value={"Assignment"}>
                                Assignment
                              </MenuItem>
                              <MenuItem sx={styling.primaryMenu} key={"Selectable"} value={"Selectable"}>
                                Selectable
                              </MenuItem>
                            </Select>
                          </FormControl>
                        </div>
                        <div className='w-[16%] pl-2'>
                          <FormControl fullWidth>
                            <TextField
                              key={selectableID}
                              label='ID'
                              color={styling.secondaryTextField}
                              defaultValue={selectableID}
                              onBlur={(event) => handleSnackbarTextUpdates(handleSelectableID, event)}
                            />
                          </FormControl>
                        </div>
                        {selectableType === "Assignment" ? (
                          <div className='w-[61%] pl-2'>
                            <FormControl fullWidth>
                              <TextField
                                required
                                key={assignmentDescription}
                                color={styling.secondaryTextField}
                                label='Assignment'
                                defaultValue={assignmentDescription}
                                onBlur={(event) => handleSnackbarTextUpdates(handleAssignmentDescription, event)}
                              />
                            </FormControl>
                          </div>
                        ) : (
                          <div className='w-[61%] pl-2'>
                            <FormControl fullWidth>
                              <TextField
                                required
                                key={selectableDescription}
                                color={styling.secondaryTextField}
                                label='Description'
                                defaultValue={selectableDescription}
                                onBlur={(event) => handleSnackbarTextUpdates(handleSelectableDescription, event)}
                              />
                            </FormControl>
                          </div>
                        )}
                        <div className='w-[6%]'>
                          <IconButton sx={{ marginBottom: "-36px" }} disabled={selectableDisabled} onClick={handleNewSelectableSubmit} variant='contained'>
                            <Tooltip title={`Add ${selectableType}`} id={"addSelectableTooltip"}>
                              <AddCircleIcon htmlColor={selectableDisabled ? lightGray : styling.secondaryColor} sx={icons.medium} />
                            </Tooltip>
                          </IconButton>
                        </div>
                      </span>
                    </div>
                  </div>
                )}
              </div>
              <CardTemplate
                type={"section"}
                header={
                  <Tooltip
                    id={"selectablesDescriptionTooltip"}
                    title={`This section allows a user to either create groups or complex 
                                             selectables based on the selectables and assignments that have 
                                             been constructed above.`}
                    arrow>
                    <label style={{ color: styling.secondaryColor }} className='resize-none font-bold text-[14px] p-0 pr-4'>
                      Selectables
                    </label>
                  </Tooltip>
                }
                body={
                  <div className='m-0 p-0 mt-[-8px]'>
                    <div className='w-full'>{getSelectableCard()}</div>
                    <div className='border-t-2 border-gray-200 m-0 p-0 pt-4 mx-[-16px]'>
                      <div className='px-4 pt-0 pb-2'>
                        <span className='min-w-full inline-flex items-baseline'>
                          <div className='w-[26%]'>
                            <FormControl fullWidth color={styling.secondaryTextField}>
                              <InputLabel key='element-select-label'>Selectable Type</InputLabel>
                              <Select
                                value={selectableGroupType}
                                label='Selectable Type'
                                autoWidth
                                onChange={handleSetSelectableGroupType}
                                sx={{ textAlign: "left" }}>
                                <MenuItem sx={styling.primaryMenu} key={"Complex Selectable"} value={"Complex Selectable"}>
                                  Complex Selectable
                                </MenuItem>
                                <MenuItem sx={styling.primaryMenu} key={"Selectable Group"} value={"Selectable Group"}>
                                  Selectable Group
                                </MenuItem>
                              </Select>
                            </FormControl>
                          </div>
                          <div className='w-[68%] pl-2'>
                            {selectableGroupType === "Complex Selectable" ? (
                              <div>
                                <FormControl fullWidth>
                                  <Tooltip id={complexSelectableID + "UserDefinedIDTooltip"} title={"User-defined ID for the new complex selectable."} arrow>
                                    <TextField
                                      required
                                      key={complexSelectableID}
                                      color={styling.secondaryTextField}
                                      label='Complex Selectable ID'
                                      defaultValue={complexSelectableID}
                                      onBlur={(event) => handleSnackbarTextUpdates(handleComplexSelectableID, event)}
                                    />
                                  </Tooltip>
                                </FormControl>
                              </div>
                            ) : (
                              <div>
                                <FormControl fullWidth>
                                  <Tooltip id={selectableGroupID + "SfrGroupIDTooltip"} title={"User-defined ID for the new group."} arrow>
                                    <TextField
                                      required
                                      key={selectableGroupID}
                                      color={styling.secondaryTextField}
                                      label='SFR Group ID'
                                      defaultValue={selectableGroupID}
                                      onBlur={(event) => handleSnackbarTextUpdates(handleSelectableGroupID, event)}
                                    />
                                  </Tooltip>
                                </FormControl>
                              </div>
                            )}
                          </div>
                          <div className='w-[6%]'>
                            <IconButton
                              sx={{ marginBottom: "-36px" }}
                              disabled={selectableGroupDisabled}
                              onClick={handleNewSelectableGroupSubmit}
                              variant='contained'>
                              <Tooltip title={"Add Selectable Group"} id={"addSelectableGroupTooltip"}>
                                <AddCircleIcon htmlColor={selectableGroupDisabled ? lightGray : styling.secondaryColor} sx={icons.medium} />
                              </Tooltip>
                            </IconButton>
                          </div>
                        </span>
                      </div>
                    </div>
                  </div>
                }
              />
            </div>
          )}
        </CardBody>
      </Card>
    </div>
  );
}

// Export SfrSelectionGroups.jsx
export default SfrSelectionGroups;
